#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>
#include "maze.h"

Maze* _malloc_maze();
void _free_maze();
void _find_maze_dimensions();
char _get_location_type();
Maze* _read_maze();
bool _write_maze();
void _find_distances();
bool _is_wall();
void _shortest_path();
bool _helper_distances(); 

Maze* _malloc_maze(int n_row, int n_col)
{
	Maze* maze = malloc(sizeof(*maze));
	maze -> maze_array = malloc(sizeof(*(maze -> maze_array)) * n_row);

	maze -> n_row = n_row;
	maze -> n_col = n_col;

	for(int i = 0; i < n_row; i++) 
	{
		maze -> maze_array[i] = malloc(sizeof(**(maze -> maze_array)) * n_col);
	}

	if(maze == NULL)
	{
		return NULL;
	}
	else if(maze -> maze_array == NULL)
	{
		free(maze);
		return NULL;
	}
	else if(maze -> maze_array[0] == NULL)
	{
		free(maze);
		free(maze -> maze_array);
		return NULL;
	}
	else
	{
		return maze;
	}
}

void _free_maze(Maze* maze)
{
	for(int i = 0; i < maze -> n_row; i++) 
	{
		free(maze -> maze_array[i]);	
	}
	free(maze -> maze_array);
	free(maze);
}

void _find_maze_dimensions(FILE* fp, int* a_rows, int* a_cols)
{
	rewind(fp);
	char ch = '0';
	bool first_row = true;
	*a_rows = 0;
	*a_cols = 0;

	while(ch != EOF)
	{
		ch = fgetc(fp);
		if(ch == '\n')
		{
			*a_rows += 1;
			first_row = false;
		}
		if(first_row == true)
		{
			*a_cols += 1;
		}
	}
	rewind(fp);
}

char _get_location_type(FILE* fp, int row, int col)
{
	rewind(fp);
	char ch = '0';
	int i = 0;
	int r = 0;
	int c = 0;
	int* a_r = &r;
	int* a_c = &c;

	_find_maze_dimensions(fp, a_r, a_c);

	while(i < row * (*a_c + 1) + col + 1)
	{
		ch = fgetc(fp);
		i++;
	}

	rewind(fp);
	return(ch);
}

Maze* _read_maze(FILE* fp)
{
	int n_row = 0;
	int n_col = 0;
	int* a_r = &n_row;
	int* a_c = &n_col;

	_find_maze_dimensions(fp, a_r, a_c);

	Maze* maze = _malloc_maze(n_row, n_col);

	rewind(fp);

	for(int i = 0; i < maze -> n_row; i++) 
	{
		for(int j = 0; j < maze -> n_col; j++) 
		{
			maze -> maze_array[i][j] = _get_location_type(fp,i,j);
		}
	}

	return maze;
}

bool _write_maze(const char* filename, const Maze* maze)
{
	FILE* fp = fopen(filename, "w");

	for(int i = 0; i < maze -> n_row; i++) 
	{
		for(int j = 0; j < maze -> n_col; j++) 
		{
			fputc(maze -> maze_array[i][j], fp); 
		}
		fputc('\n', fp);
	}

	fclose(fp);

	return true;
}
/* this is a function implemented by the instructor to illustrate           */
/* how to use a recursive function to go from the left-most top entrance to */
/* the right-most bottom exit of a maze.  The function will print the       */
/* directions taken to reach the bottom exit, without visiting a location   */
/* twice.  Note that the recursion may visit a location a few times         */
/* Given three filenames, first one is a given maze, the second one is to   */
/* be written with the directions, the third is the explored maze           */
/* If the maze file does not exist, the function immediately return -1 and  */
/* do nothing else                                                          */
/* the directions are in the form of a series of characters                 */
/* 'N', 'S', 'E', 'W', without spacing (and without the quotes).            */
/* There should be just a single line, without a terminating newline        */
/* character. In other words, to the vi editor, it is an incomplete file    */
/* you are to assume that you start from the top-most, left-most entry      */
/* of the maze.  Therefore, the first direction is always 'S'               */
/* similarly, the last direction is always 'S'                              */
/* the returned value should be the number of steps taken to reach          */
/* the right-most bottom exit.  It is typically not the shortest distance   */
/* Note that the maze can be generated by amaze, or some combinations of    */
/* the maze expansion functions that you have written in PE08               */
/* you may assume that the maze file, if it exists, is in the correct format*/
static bool is_path(Maze *maze, int row, int col)
{
   if ((row >= 0) && (row < maze->n_row)) {
      if ((col >= 0) && (col < maze->n_col)) {
         return maze->maze_array[row][col] == PATH;
      }
   }
   return false;
}

/* given a maze, current row (curr),                                     */
/* current column (curc), destination row (drow), destination col (dcol) */
/* current distance from source, determine the where to explore from the */
/* current location                                                      */
/* a recursive function: from the current location, try 'N', 'S', 'E',   */
/* 'W' locations one at a time if the attempt is successful, write the   */
/* direction in the file                                                 */

static int _pathfinder_helper(Maze *maze, int curr, int curc, int endr, int endc,
                            int count, FILE *dfptr)
{
   // you may uncomment this and use the output here to trace the function
   // with sample5.pdf
   // printf("(%d, %d), %d\n", curr, curc, count);
   maze->maze_array[curr][curc] = VISITED;
   if ((curr == endr) && (curc == endc)) { // reach the destination 
      int i;
      for (i = 0; i < count; i++) { // create enough space in file
         fputc(VISITED, dfptr);
      }
      return count;
   }

   int found = -1;
   int found2 = -1;
   int found3 = -1;
   int found4 = -1;

   if (is_path(maze, curr-1, curc)) { 
      found = _pathfinder_helper(maze, curr-1, curc, endr, endc, count+1, dfptr);
      if (found != -1) {
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //fputc('N', dfptr);
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //return found;
      }
   }
   if (is_path(maze, curr+1, curc)) {
      found2 = _pathfinder_helper(maze, curr+1, curc, endr, endc, count+1, dfptr);
      if (found != -1) {
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //fputc('S', dfptr);
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //return found;
      }
   }
   if (is_path(maze, curr, curc+1)) {
      found3 = _pathfinder_helper(maze, curr, curc+1, endr, endc, count+1, dfptr);
      if (found != -1) {
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //fputc('E', dfptr);
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //return found;
      }
   }
   if (is_path(maze, curr, curc-1)) {
      found4 = _pathfinder_helper(maze, curr, curc-1, endr, endc, count+1, dfptr);
      if (found != -1) {
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
         //fputc('W', dfptr);
         //fseek(dfptr, -1, SEEK_CUR); // go back one position
      }
   }
   if(found != -1)
   {
		count = found;
   }
   if(found2 != -1 && found2 < count)
   {
	   count = found2;
   }
   if(found3 != -1 && found3 < count)
   {
	   count = found3;
   }
   if(found4 != -1 && found4 < count)
   {
	   count = found4;
   }

   return count;
}
int find_path_from_top_entrance_to_bottom_exit(char *maze_file, char *directions_file, char *visited_file)
{
   FILE *mfptr = fopen(maze_file, "r");
   if (mfptr == NULL) {
      return -1;
   }
   
   /* read the maze from mfptr */

   Maze *maze = _read_maze(mfptr);
   fclose(mfptr);
   if (maze == NULL) {
      return -1;
   }
   
   /* find the starting location, the top-most, left-most opening */
   int startr, startc;
   startr = 0;
   for (startc = 0; startc < maze->n_col; startc++) {
      if (maze->maze_array[startr][startc] == PATH) {
         break;
      }
   }

   /* find the ending location, the bottom-most, right most opening */
   int endr, endc;
   endr = maze->n_row-1;
   for (endc = maze->n_col-1; endc >= 0; endc--) {
      if (maze->maze_array[endr][endc] == PATH) {
         break;
      }
   } 

   // no starting location, deallocate and return 
   if (startc == maze->n_col) {
      _free_maze(maze);
      return -1;
   }
   // no ending location, deallocate and return 
   if (endc == -1) {
      _free_maze(maze);
      return -1;
   }

   FILE *dfptr = fopen(directions_file, "w");
   if (dfptr == NULL) {
      _free_maze(maze);
      return -1;
   }
   int steps = _pathfinder_helper(maze, startr, startc, endr, endc, 0, dfptr);
   _write_maze(visited_file, maze);
   fclose(dfptr);
   _free_maze(maze);
   return steps;
}
bool _helper_distances(Maze *maze, int row, int col, int** dists, int count)
{
	if(row >= maze -> n_row || col >= maze -> n_col || row < 0 || col < 0)
	{
		return false;
	}
	if(maze -> maze_array[row][col] == VISITED)
	{
		if(dists[row][col] > count)
		{
			return true;
		}
	}
	else if(maze -> maze_array[row][col] == PATH)
	{
		return true;
	}
	
	return false;
	
}
void _find_distances(Maze *maze, int curr, int curc, int endr, int endc, int count,  int** dists)
{
	maze->maze_array[curr][curc] = VISITED;
	if(curr == curc && endr == endc)
	{
		return;
	}
	if (_helper_distances(maze, curr + 1, curc, dists, count + 1)) 
	{
		if(dists[curr + 1][curc] == -1 || dists[curr + 1][curc] > count + 1)
		{
			dists[curr + 1][curc] = count + 1;
		}
		
		_find_distances(maze, curr + 1, curc, endr, endc, count + 1, dists);
	}
	if (_helper_distances(maze, curr - 1, curc, dists, count + 1)) 
	{
		if(dists[curr - 1][curc] == -1 || dists[curr - 1][curc] > count + 1)
		{
			dists[curr - 1][curc] = count + 1;
		}

		_find_distances(maze, curr - 1, curc, endr, endc, count + 1, dists);
	}
	if (_helper_distances(maze, curr, curc + 1, dists, count + 1)) 
	{
		if(dists[curr][curc + 1] == -1 || dists[curr][curc + 1] > count + 1)
		{
			dists[curr][curc + 1] = count + 1;
		}

		_find_distances(maze, curr, curc + 1, endr, endc, count + 1, dists);
	}
	if (_helper_distances(maze, curr, curc - 1, dists, count + 1)) 
	{
		if(dists[curr][curc - 1] == -1 || dists[curr][curc - 1] > count + 1)
		{
			dists[curr][curc - 1] = count + 1;
		}
		
		_find_distances(maze, curr, curc - 1, endr, endc, count + 1, dists);
	}
}
bool _is_wall(Maze* maze, int** dists, int row, int col)
{
	bool wall = false;
   if ((row >= 0) && (row < maze->n_row)) 
   {
      if ((col >= 0) && (col < maze->n_col)) 
	  {
         if(dists[row][col] == -1)
		 {
			wall = true;
		 }
      }
   }
   else
   {
	   if(row >= maze -> n_row || row < 0)
	   {
		   wall = true;
	   }
	   else if(col >= maze -> n_col || col < 0)
	   {
		   wall = true;
	   }
   }
   return wall;
   
}
void _shortest_path(Maze* maze, int** dists, int endr, int endc, char* directions, int count)
{
	if(dists[endr][endc] == 0)
	{
		return;
	}

	int short_path[4];
	if(!_is_wall(maze, dists, endr + 1, endc))
	{
		short_path[0] = dists[endr + 1][endc];
	}
	else
	{
		short_path[0] = -1;
	}
	if(!_is_wall(maze, dists, endr - 1, endc))
	{
		short_path[1] = dists[endr - 1][endc];
	}
	else
	{
		short_path[1] = -1;
	}
	if(!_is_wall(maze, dists, endr, endc + 1))
	{
		short_path[2] = dists[endr][endc + 1];
	}
	else
	{
		short_path[2] = -1;
	}
	if(!_is_wall(maze, dists, endr, endc - 1))
	{
		short_path[3] = dists[endr][endc - 1];
	}
	else
	{
		short_path[3] = -1;
	}
	
	int shortest = INT_MAX;

	if(short_path[0] >= 0)                                 //checks which directions has shortest count (must be non -1)
	{
		shortest = short_path[0];
	}
	if(short_path[1] >= 0 && short_path[1] < shortest)
	{
		shortest = short_path[1];
	}
	if(short_path[2] >= 0 && short_path[2] < shortest)
	{
		shortest = short_path[2];
	}
	if(short_path[3] >= 0 && short_path[3] < shortest)
	{
		shortest = short_path[3];
	}

	if(shortest == short_path[0])
	{	
		directions[count] = 'N';
		_shortest_path(maze, dists, endr + 1, endc, directions, count + 1);
	}
	if(shortest == short_path[1])
	{
		directions[count] = 'S';
		_shortest_path(maze, dists, endr - 1, endc, directions, count + 1);
	}
	if(shortest == short_path[2])
	{
		directions[count] = 'W';
		_shortest_path(maze, dists, endr, endc + 1, directions, count + 1);
	}
	if(shortest == short_path[3])
	{
		directions[count] = 'E';
		_shortest_path(maze, dists, endr, endc - 1, directions, count + 1);
	}
}

int dfs_shortest_path_directions(char *maze_file, char *directions_file,
                        Coord source, Coord destination)
{
	FILE* fp = fopen(maze_file, "r");
    if (fp == NULL) 
	{
       return -1;
    }

    Maze *maze = _read_maze(fp);
    fclose(fp);

    if (maze == NULL) 
    {
       return -1;
    }
   
    if (source.col >= maze -> n_col) 
	{
       _free_maze(maze);
       return -1;
    }

    if (source.row >= maze -> n_row) 
	{
       _free_maze(maze);
       return -1;
    }
  	
	if (destination.col >= maze -> n_col) 
	{
       _free_maze(maze);
       return -1;
    }

    if (destination.row >= maze -> n_row) 
	{
       _free_maze(maze);
       return -1;
    }

	int** distances = malloc(sizeof(*distances) * maze -> n_row);
	for(int i = 0; i < maze -> n_row; i++)
	{
		distances[i] = malloc(sizeof(**distances) * maze -> n_col);
	}
	for(int i = 0; i < maze -> n_row; i++) 
	{
		for(int j = 0; j < maze -> n_col; j++) 
		{
			distances[i][j] = -1;
		}
	}

	distances[source.row][source.col] = 0;

	_find_distances(maze, source.row, source.col, destination.row, destination.col, 0, distances); // creates 2d array paths = distance from source walls = -1

	/*for(int i = 0; i < maze -> n_row; i++) 
	{
		for(int j = 0; j < maze -> n_col; j++) 
		{
			if(distances[i][j] == -1)
			{
				printf(" %c", 'X');						//Prints distances 2D array
			}
			else
			{
				printf("%2.d", distances[i][j]);
			}
		}
		printf("\n");
	}*/
	
	char* directions = malloc(sizeof(*directions) * distances[destination.row][destination.col]); // string of directions in reverse order

	_shortest_path(maze, distances, destination.row, destination.col, directions, 0); // writes the directions to the char* directions string (reverse order)

	FILE* fp_dir = fopen(directions_file, "w");
	if(fp_dir == NULL)
	{
		_free_maze(maze);
		return -1;
	}
	
	for(int i = distances[destination.row][destination.col] - 1; i >= 0; i--) // writes the string (directions) in reverse order
	{
		fputc(directions[i], fp_dir);
	}
	fclose(fp_dir);
	
	int total_distance = distances[destination.row][destination.col];
	
	free(directions);
	for(int i = 0; i < maze -> n_row; i++) 
	{
		free(distances[i]);
	}
	free(distances);
	_free_maze(maze);
	
	return total_distance;
}
int simulate_movement(char *maze_file, char *directions_file, char *visited_file,
                      Coord source, Coord destination)
{
	FILE* fp = fopen(maze_file, "r");
    if (fp == NULL) 
	{
       return -1;
    }
   
    Maze *maze = _read_maze(fp);
    fclose(fp);
    if (maze == NULL) 
	{
      return -1;
    }
   
	if (source.col >= maze -> n_col) 
	{
       _free_maze(maze);
       return -1;
    }

    if (source.row >= maze -> n_row) 
	{
       _free_maze(maze);
       return -1;
    }
  	
	if (destination.col >= maze -> n_col) 
	{
       _free_maze(maze);
       return -1;
    }

    if (destination.row >= maze -> n_row) 
	{
       _free_maze(maze);
       return -1;
    }
	if(maze -> maze_array[source.row][source.col] == WALL || maze -> maze_array[destination.row][destination.col] == WALL)
	{
		_free_maze(maze);
		return -1;
	}

    FILE* dir_fp = fopen(directions_file, "r");
    if (dir_fp == NULL)
    {
       _free_maze(maze);
       return -1;
    }
    
	
	maze -> maze_array[source.row][source.col] = VISITED;

	char ch = '0';
	int cr = source.row;
	int cc = source.col;
	int counter = 1;

	rewind(dir_fp);

	while(ch != EOF)
	{
		ch = fgetc(dir_fp);
		if(ch == 'N')
		{
			cr--;
			if((cr < maze -> n_row && cc < maze -> n_col) && (cr >= 0 && cc >= 0))		
			{
				if(maze -> maze_array[cr][cc] == PATH)
				{
					maze -> maze_array[cr][cc] = VISITED;
					counter++;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
		else if(ch == 'S')
		{
			cr++;
			if((cr < maze -> n_row && cc < maze -> n_col) && (cr >= 0 && cc >= 0))
			{
				if(maze -> maze_array[cr][cc] == PATH)
				{
					maze -> maze_array[cr][cc] = VISITED;
					counter++;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
		else if(ch == 'E')
		{
			cc++;
			if((cr < maze -> n_row && cc < maze -> n_col) && (cr >= 0 && cc >= 0))
			{
				if(maze -> maze_array[cr][cc] == PATH)
				{
					maze -> maze_array[cr][cc] = VISITED;
					counter++;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
		else if(ch == 'W')
		{
			cc--;
			if((cr < maze -> n_row && cc < maze -> n_col) && (cr >= 0 && cc >= 0))
			{
				if(maze -> maze_array[cr][cc] == PATH)
				{
					maze -> maze_array[cr][cc] = VISITED;
					counter++;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
		else
		{
			break;
		}
	}

	_write_maze(visited_file, maze);

	_free_maze(maze);

	fclose(dir_fp);

	if(cr == destination.row && cc == destination.col)
	{
		return counter;
	}
	else
	{
		return -1;
	}
}
