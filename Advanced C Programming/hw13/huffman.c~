#include "huffman.h"
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <string.h>

void _output_file_1(char* input, char* output)
{
	FILE* fp_input  = fopen(input, "r");
	FILE* fp_output = fopen(output, "w");
	char ch         = 0;
	long int occurances  = 0;

	for(int i = 0; i < 256; i++) 
	{
		ch = i;
		occurances = _ascii_occurances(ch, fp_input);
		fprintf(fp_output, "%ld\n", occurances);
	}

	fclose(fp_input);
	fclose(fp_output);
}

void _output_file_2(char* ascii_occurances, char* output, Node** pq)
{
	FILE* fp_input  = fopen(ascii_occurances, "r");
	FILE* fp_output = fopen(output, "w");
	
	long int amount = 0;
	int ascii_num   = 0;

	while(!feof(fp_input))
	{
		fscanf(fp_input, "%ld", &amount);

		if(amount != 0)
		{
			_pq_enqueue(pq, amount, ascii_num, NULL, NULL);
		}

		ascii_num++;
	}
	_print_node(*pq, fp_output);
	
		
	fclose(fp_input);
	fclose(fp_output);
}
void _output_file_3(Node** pq, char* output)
{
	FILE* fp_output = fopen(output, "w");

	Node* pop_node_1 = malloc(sizeof(*pop_node_1));
	Node* pop_node_2 = malloc(sizeof(*pop_node_2));
	
	while((*pq) -> next != NULL)
	{
		_pq_dequeue(pq, &pop_node_1);
		_pq_dequeue(pq, &pop_node_2);
		_pq_enqueue(pq, pop_node_1 -> tree -> amount + pop_node_2  -> tree -> amount, 260, pop_node_1 -> tree, pop_node_2 -> tree);
	}
	_destroy_node(pop_node_1);
	_destroy_node(pop_node_2);


	char* path = malloc(sizeof(*path) * (*pq) -> tree -> amount);

	print_output3(fp_output, (*pq) -> tree, path, 0);

	fclose(fp_output);

	free(path);
}

void print_output3(FILE* fp, TreeNode* tree, char* path, int i)
{
	if(tree -> ascii != 260)
	{
		fprintf(fp, "%c:", tree -> ascii);
		path[i] = '\0';
		fprintf(fp, "%s\n", path);
		return;
	}
	else
	{
		path[i] = '0';
		print_output3(fp, tree -> left, path, i + 1);
		path[i] = '1';
		print_output3(fp, tree -> right, path, i + 1);
	}	
}

long int _ascii_occurances(char ch, FILE* fp) // counts the number of occurances of character ch
{
	rewind(fp);
	
	long int occurances = 0;
	char temp_ch = '0';

	while(temp_ch != EOF)
	{
		if(ch == EOF)
		{
			return occurances;
		}
		temp_ch = fgetc(fp);
		if(temp_ch == ch)
		{
			occurances++;
		}
	}
	return occurances;
}

void _destroy_node(Node* list)
{
	if(list != NULL)
	{	
		if(list -> tree != NULL)
		{
			_destroy_tree_node(list -> tree);
		}
	}
	if(list != NULL)
	{
		_destroy_node(list -> next);
		free(list);
	}
}
void _destroy_tree_node(TreeNode* tree)
{
	if(tree != NULL)
	{
		_destroy_tree_node(tree -> left);
		_destroy_tree_node(tree -> right);
		free(tree);
	}
}

void _print_node(const Node *list, FILE* output)
{
   while (list != NULL) 
   { 
      fprintf(output, "%c:%ld->", list -> tree -> ascii, list -> tree -> amount);
      list = list->next;
   } 
   fprintf(output, "NULL\n");
}
void  _pq_enqueue(Node** pq, long int amount, int ascii, TreeNode* left_node, TreeNode* right_node)
{	
    TreeNode* new_tree_node = malloc(sizeof(*new_tree_node)); 
	new_tree_node -> amount = amount;
	new_tree_node -> ascii  = ascii;
	new_tree_node -> left   = left_node;
	new_tree_node -> right  = right_node;
	Node* new_node = malloc(sizeof(*new_node));
	new_node -> tree = new_tree_node;

	if(*pq == NULL)
	{	
		new_node -> next = NULL;
		*pq = new_node;
		return;
	}
	
	Node* curr      = *pq;
	Node* prev_node = *pq;

	long int first = (*pq) -> tree -> amount;
	if(first - new_node ->  tree -> amount > 0)		
	{
		new_node -> next = *pq;
		*pq              = new_node;
		return;
	}

	bool prev = true;
	
	while(curr != NULL)
	{
		if(curr -> tree -> amount == new_node ->  tree -> amount)
		{
			curr = *pq;
			prev = true;
			prev_node = *pq;
			
			while(new_node -> tree -> amount != curr -> tree -> amount)
			{
				curr = curr -> next;
				if(prev == false)
				{
					prev_node = prev_node -> next;
				}
				prev = false;
			}
			int first_ascii = curr -> tree -> ascii;
			if(first_ascii == (*pq) -> tree -> ascii && new_node -> tree -> ascii < first_ascii)
			{
				new_node -> next = curr;
				*pq = new_node;
				return;
			}
			if(first_ascii - new_node -> tree -> ascii > 0) // middle ascii value
			{
				new_node -> next = curr;
				prev_node -> next = new_node;
				return;
			}
			else
			{
				curr = *pq;
				prev = true;
				prev_node = *pq;

				while(curr != NULL)
				{
					if(new_node -> tree -> amount == curr -> tree -> amount)
					{
						if(new_node -> tree -> ascii < curr -> tree -> ascii) // somewhere in middle
						{
							new_node -> next = curr;
							prev_node -> next = new_node;
							return;
						}
						else if(new_node -> tree -> ascii == curr -> tree -> ascii)
						{
							Node* check_end = curr;

							while(check_end -> next != NULL)
							{
								check_end = check_end -> next;
							}
							if(new_node -> tree -> ascii == check_end -> tree -> ascii)
							{
								check_end -> next = new_node;
								new_node -> next = NULL;
								return;
							}
							prev = true;
							prev_node = curr;
							while(new_node -> tree -> ascii == curr -> next -> tree -> ascii) // look to see where the last parent node for this frequency is insert new parents after that node
							{
								if(prev == false)
								{
									prev_node = prev_node -> next;
								}
								curr = curr -> next;
								prev = false;
							}
							new_node -> next = curr -> next;
							prev_node -> next = new_node;
							return;
						}
						else
						{
							Node* end_ascii = curr;
							while(new_node -> tree -> amount == end_ascii -> tree -> amount)
							{
								if(end_ascii -> next == NULL)
								{
									break;
								}
								if(end_ascii -> next -> tree -> amount != new_node -> tree -> amount)
								{
									break;
								}
								end_ascii = end_ascii -> next;
							}
							if(end_ascii -> tree -> ascii < new_node -> tree -> ascii) // if ascii value should be last for that given amount
							{
								Node* temp = end_ascii -> next;
								end_ascii -> next = new_node;
								new_node -> next = temp;
								return;
							}
						}
					}
					if(prev == false)
					{
						prev_node = prev_node -> next;
					}
					curr = curr -> next;
					prev = false;
				
				}
			return;
			}
		}
		
		else if(curr -> tree -> amount - new_node -> tree -> amount > 0)
		{											//If node is somewhere inbetween amount already in list		
			new_node -> next  = curr;
			prev_node -> next = new_node;
			return;
		}
		else
		{	
			Node* end_node = *pq;
			while(end_node -> next != NULL) // finds second to last node
			{
				end_node = end_node -> next;
			}
			if(end_node -> tree -> amount - new_node -> tree -> amount < 0)	//If node should be last in list
			{
				new_node -> next = NULL;
				end_node -> next = new_node;
				return;
			}
		}
		if(prev == false)
		{
			prev_node = prev_node -> next;
		}
		curr = curr -> next;
		prev = false;
	}	
    return;
}
void  _pq_dequeue(Node** pq, Node** popped_node)  
{
	if(*pq == NULL)
	{
		return;
	}
	(*popped_node) -> tree = (*pq) -> tree;
	(*popped_node) -> next = NULL;
	Node* temp = *pq;
	*pq = (*pq) -> next;
	free(temp);

}
